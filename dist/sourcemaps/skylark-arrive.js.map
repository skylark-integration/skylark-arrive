{"version":3,"sources":["skylark-arrive.js"],"names":["define","skylark","$","window","MutationObserver","HTMLElement","matches","arriveUniqueId","utils","prototype","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","matchesSelector","elem","selector","call","addMethod","object","name","fn","old","length","arguments","apply","this","callCallbacks","callbacksToBeCalled","registrationData","options","onceOnly","firedElems","cb","i","callback","me","unbindEventWithSelectorAndCallback","target","checkChildNodesRecursively","nodes","matchFunc","node","push","childNodes","mergeArrays","firstArr","secondArr","attrName","hasOwnProperty","toElementsArray","elements","EventsBucket","_eventsBucket","_beforeAdding","_beforeRemoving","addEvent","newEvent","removeEvent","compareFunction","registeredEvent","removedEvents","splice","beforeAdding","beforeRemoving","MutationEvents","getObserverConfig","onMutation","eventsBucket","defaultOptions","fireOnAttributesModification","observer","document","getElementsByTagName","e","config","observe","eventData","disconnect","bindEvent","unbindEvent","eventObj","undefined","unbindEventWithSelectorOrCallback","arriveEvents","arriveDefaultOptions","existing","nodeMatchFunc","_id","indexOf","mutationBindEvent","attributes","childList","subtree","mutations","forEach","mutation","newNodes","addedNodes","targetNode","type","querySelectorAll","j","setTimeout","leaveEvents","leaveDefaultOptions","removedNodes","exposeApi","NodeList","HTMLCollection","HTMLDocument","Window","arrive","exposeUnbindApi","attach","exposeTo","funcName","leave","main"],"mappings":"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","file":"../skylark-arrive.js","sourcesContent":["/*globals jQuery,Window,HTMLElement,HTMLDocument,HTMLCollection,NodeList,MutationObserver */\n/*exported Arrive*/\n/*jshint latedef:false */\n\n/*\n * arrive.js\n * v2.4.1\n * https://github.com/uzairfarooq/arrive\n * MIT licensed\n *\n * Copyright (c) 2014-2017 Uzair Farooq\n */\ndefine('skylark-arrive/arrive',[\n  \"skylark-langx/skylark\",\n  \"skylark-jquery\"\n],function(skylark,$) {\n\n  \"use strict\";\n\n  if(!window.MutationObserver || typeof HTMLElement === 'undefined'){\n    return; //for unsupported browsers\n  }\n\n  var arriveUniqueId = 0;\n\n  var utils = (function() {\n    var matches = HTMLElement.prototype.matches || HTMLElement.prototype.webkitMatchesSelector || HTMLElement.prototype.mozMatchesSelector\n                  || HTMLElement.prototype.msMatchesSelector;\n\n    return {\n      matchesSelector: function(elem, selector) {\n        return elem instanceof HTMLElement && matches.call(elem, selector);\n      },\n      // to enable function overloading - By John Resig (MIT Licensed)\n      addMethod: function (object, name, fn) {\n        var old = object[ name ];\n        object[ name ] = function(){\n          if ( fn.length == arguments.length ) {\n            return fn.apply( this, arguments );\n          }\n          else if ( typeof old == 'function' ) {\n            return old.apply( this, arguments );\n          }\n        };\n      },\n      callCallbacks: function(callbacksToBeCalled, registrationData) {\n        if (registrationData && registrationData.options.onceOnly && registrationData.firedElems.length == 1) {\n          // as onlyOnce param is true, make sure we fire the event for only one item\n          callbacksToBeCalled = [callbacksToBeCalled[0]];\n        }\n\n        for (var i = 0, cb; (cb = callbacksToBeCalled[i]); i++) {\n          if (cb && cb.callback) {\n            cb.callback.call(cb.elem, cb.elem);\n          }\n        }\n\n        if (registrationData && registrationData.options.onceOnly && registrationData.firedElems.length == 1) {\n          // unbind event after first callback as onceOnly is true.\n          registrationData.me.unbindEventWithSelectorAndCallback.call(\n            registrationData.target, registrationData.selector, registrationData.callback);\n        }\n      },\n      // traverse through all descendants of a node to check if event should be fired for any descendant\n      checkChildNodesRecursively: function(nodes, registrationData, matchFunc, callbacksToBeCalled) {\n        // check each new node if it matches the selector\n        for (var i=0, node; (node = nodes[i]); i++) {\n          if (matchFunc(node, registrationData, callbacksToBeCalled)) {\n            callbacksToBeCalled.push({ callback: registrationData.callback, elem: node });\n          }\n\n          if (node.childNodes.length > 0) {\n            utils.checkChildNodesRecursively(node.childNodes, registrationData, matchFunc, callbacksToBeCalled);\n          }\n        }\n      },\n      mergeArrays: function(firstArr, secondArr){\n        // Overwrites default options with user-defined options.\n        var options = {},\n            attrName;\n        for (attrName in firstArr) {\n          if (firstArr.hasOwnProperty(attrName)) {\n            options[attrName] = firstArr[attrName];\n          }\n        }\n        for (attrName in secondArr) {\n          if (secondArr.hasOwnProperty(attrName)) {\n            options[attrName] = secondArr[attrName];\n          }\n        }\n        return options;\n      },\n      toElementsArray: function (elements) {\n        // check if object is an array (or array like object)\n        // Note: window object has .length property but it's not array of elements so don't consider it an array\n        if (typeof elements !== \"undefined\" && (typeof elements.length !== \"number\" || elements === window)) {\n          elements = [elements];\n        }\n        return elements;\n      }\n    };\n  })();\n\n\n  // Class to maintain state of all registered events of a single type\n  var EventsBucket = (function() {\n    var EventsBucket = function() {\n      // holds all the events\n\n      this._eventsBucket    = [];\n      // function to be called while adding an event, the function should do the event initialization/registration\n      this._beforeAdding    = null;\n      // function to be called while removing an event, the function should do the event destruction\n      this._beforeRemoving  = null;\n    };\n\n    EventsBucket.prototype.addEvent = function(target, selector, options, callback) {\n      var newEvent = {\n        target:             target,\n        selector:           selector,\n        options:            options,\n        callback:           callback,\n        firedElems:         []\n      };\n\n      if (this._beforeAdding) {\n        this._beforeAdding(newEvent);\n      }\n\n      this._eventsBucket.push(newEvent);\n      return newEvent;\n    };\n\n    EventsBucket.prototype.removeEvent = function(compareFunction) {\n      for (var i=this._eventsBucket.length - 1, registeredEvent; (registeredEvent = this._eventsBucket[i]); i--) {\n        if (compareFunction(registeredEvent)) {\n          if (this._beforeRemoving) {\n              this._beforeRemoving(registeredEvent);\n          }\n\n          // mark callback as null so that even if an event mutation was already triggered it does not call callback\n          var removedEvents = this._eventsBucket.splice(i, 1);\n          if (removedEvents && removedEvents.length) {\n            removedEvents[0].callback = null;\n          }\n        }\n      }\n    };\n\n    EventsBucket.prototype.beforeAdding = function(beforeAdding) {\n      this._beforeAdding = beforeAdding;\n    };\n\n    EventsBucket.prototype.beforeRemoving = function(beforeRemoving) {\n      this._beforeRemoving = beforeRemoving;\n    };\n\n    return EventsBucket;\n  })();\n\n\n  /**\n   * @constructor\n   * General class for binding/unbinding arrive and leave events\n   */\n  var MutationEvents = function(getObserverConfig, onMutation) {\n    var eventsBucket    = new EventsBucket(),\n        me              = this;\n\n    var defaultOptions = {\n      fireOnAttributesModification: false\n    };\n\n    // actual event registration before adding it to bucket\n    eventsBucket.beforeAdding(function(registrationData) {\n      var\n        target    = registrationData.target,\n        observer;\n\n      // mutation observer does not work on window or document\n      if (target === window.document || target === window) {\n        target = document.getElementsByTagName(\"html\")[0];\n      }\n\n      // Create an observer instance\n      observer = new MutationObserver(function(e) {\n        onMutation.call(this, e, registrationData);\n      });\n\n      var config = getObserverConfig(registrationData.options);\n\n      observer.observe(target, config);\n\n      registrationData.observer = observer;\n      registrationData.me = me;\n    });\n\n    // cleanup/unregister before removing an event\n    eventsBucket.beforeRemoving(function (eventData) {\n      eventData.observer.disconnect();\n    });\n\n    this.bindEvent = function(selector, options, callback) {\n      options = utils.mergeArrays(defaultOptions, options);\n\n      var elements = utils.toElementsArray(this);\n\n      for (var i = 0; i < elements.length; i++) {\n        eventsBucket.addEvent(elements[i], selector, options, callback);\n      }\n    };\n\n    this.unbindEvent = function() {\n      var elements = utils.toElementsArray(this);\n      eventsBucket.removeEvent(function(eventObj) {\n        for (var i = 0; i < elements.length; i++) {\n          if (this === undefined || eventObj.target === elements[i]) {\n            return true;\n          }\n        }\n        return false;\n      });\n    };\n\n    this.unbindEventWithSelectorOrCallback = function(selector) {\n      var elements = utils.toElementsArray(this),\n          callback = selector,\n          compareFunction;\n\n      if (typeof selector === \"function\") {\n        compareFunction = function(eventObj) {\n          for (var i = 0; i < elements.length; i++) {\n            if ((this === undefined || eventObj.target === elements[i]) && eventObj.callback === callback) {\n              return true;\n            }\n          }\n          return false;\n        };\n      }\n      else {\n        compareFunction = function(eventObj) {\n          for (var i = 0; i < elements.length; i++) {\n            if ((this === undefined || eventObj.target === elements[i]) && eventObj.selector === selector) {\n              return true;\n            }\n          }\n          return false;\n        };\n      }\n      eventsBucket.removeEvent(compareFunction);\n    };\n\n    this.unbindEventWithSelectorAndCallback = function(selector, callback) {\n      var elements = utils.toElementsArray(this);\n      eventsBucket.removeEvent(function(eventObj) {\n          for (var i = 0; i < elements.length; i++) {\n            if ((this === undefined || eventObj.target === elements[i]) && eventObj.selector === selector && eventObj.callback === callback) {\n              return true;\n            }\n          }\n          return false;\n      });\n    };\n\n    return this;\n  };\n\n\n  /**\n   * @constructor\n   * Processes 'arrive' events\n   */\n  var ArriveEvents = function() {\n    // Default options for 'arrive' event\n    var arriveDefaultOptions = {\n      fireOnAttributesModification: false,\n      onceOnly: false,\n      existing: false\n    };\n\n    function getArriveObserverConfig(options) {\n      var config = {\n        attributes: false,\n        childList: true,\n        subtree: true\n      };\n\n      if (options.fireOnAttributesModification) {\n        config.attributes = true;\n      }\n\n      return config;\n    }\n\n    function onArriveMutation(mutations, registrationData) {\n      mutations.forEach(function( mutation ) {\n        var newNodes    = mutation.addedNodes,\n            targetNode = mutation.target,\n            callbacksToBeCalled = [],\n            node;\n\n        // If new nodes are added\n        if( newNodes !== null && newNodes.length > 0 ) {\n          utils.checkChildNodesRecursively(newNodes, registrationData, nodeMatchFunc, callbacksToBeCalled);\n        }\n        else if (mutation.type === \"attributes\") {\n          if (nodeMatchFunc(targetNode, registrationData, callbacksToBeCalled)) {\n            callbacksToBeCalled.push({ callback: registrationData.callback, elem: targetNode });\n          }\n        }\n\n        utils.callCallbacks(callbacksToBeCalled, registrationData);\n      });\n    }\n\n    function nodeMatchFunc(node, registrationData, callbacksToBeCalled) {\n      // check a single node to see if it matches the selector\n      if (utils.matchesSelector(node, registrationData.selector)) {\n        if(node._id === undefined) {\n          node._id = arriveUniqueId++;\n        }\n        // make sure the arrive event is not already fired for the element\n        if (registrationData.firedElems.indexOf(node._id) == -1) {\n          registrationData.firedElems.push(node._id);\n\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    arriveEvents = new MutationEvents(getArriveObserverConfig, onArriveMutation);\n\n    var mutationBindEvent = arriveEvents.bindEvent;\n\n    // override bindEvent function\n    arriveEvents.bindEvent = function(selector, options, callback) {\n\n      if (typeof callback === \"undefined\") {\n        callback = options;\n        options = arriveDefaultOptions;\n      } else {\n        options = utils.mergeArrays(arriveDefaultOptions, options);\n      }\n\n      var elements = utils.toElementsArray(this);\n\n      if (options.existing) {\n        var existing = [];\n\n        for (var i = 0; i < elements.length; i++) {\n          var nodes = elements[i].querySelectorAll(selector);\n          for (var j = 0; j < nodes.length; j++) {\n            existing.push({ callback: callback, elem: nodes[j] });\n          }\n        }\n\n        // no need to bind event if the callback has to be fired only once and we have already found the element\n        if (options.onceOnly && existing.length) {\n          return callback.call(existing[0].elem, existing[0].elem);\n        }\n\n        setTimeout(utils.callCallbacks, 1, existing);\n      }\n\n      mutationBindEvent.call(this, selector, options, callback);\n    };\n\n    return arriveEvents;\n  };\n\n\n  /**\n   * @constructor\n   * Processes 'leave' events\n   */\n  var LeaveEvents = function() {\n    // Default options for 'leave' event\n    var leaveDefaultOptions = {};\n\n    function getLeaveObserverConfig() {\n      var config = {\n        childList: true,\n        subtree: true\n      };\n\n      return config;\n    }\n\n    function onLeaveMutation(mutations, registrationData) {\n      mutations.forEach(function( mutation ) {\n        var removedNodes  = mutation.removedNodes,\n            callbacksToBeCalled = [];\n\n        if( removedNodes !== null && removedNodes.length > 0 ) {\n          utils.checkChildNodesRecursively(removedNodes, registrationData, nodeMatchFunc, callbacksToBeCalled);\n        }\n\n        utils.callCallbacks(callbacksToBeCalled, registrationData);\n      });\n    }\n\n    function nodeMatchFunc(node, registrationData) {\n      return utils.matchesSelector(node, registrationData.selector);\n    }\n\n    leaveEvents = new MutationEvents(getLeaveObserverConfig, onLeaveMutation);\n\n    var mutationBindEvent = leaveEvents.bindEvent;\n\n    // override bindEvent function\n    leaveEvents.bindEvent = function(selector, options, callback) {\n\n      if (typeof callback === \"undefined\") {\n        callback = options;\n        options = leaveDefaultOptions;\n      } else {\n        options = utils.mergeArrays(leaveDefaultOptions, options);\n      }\n\n      mutationBindEvent.call(this, selector, options, callback);\n    };\n\n    return leaveEvents;\n  };\n\n\n  var arriveEvents = new ArriveEvents(),\n      leaveEvents  = new LeaveEvents();\n\n  function exposeUnbindApi(eventObj, exposeTo, funcName) {\n    // expose unbind function with function overriding\n    utils.addMethod(exposeTo, funcName, eventObj.unbindEvent);\n    utils.addMethod(exposeTo, funcName, eventObj.unbindEventWithSelectorOrCallback);\n    utils.addMethod(exposeTo, funcName, eventObj.unbindEventWithSelectorAndCallback);\n  }\n\n  /*** expose APIs ***/\n  function exposeApi(exposeTo) {\n    exposeTo.arrive = arriveEvents.bindEvent;\n    exposeUnbindApi(arriveEvents, exposeTo, \"unbindArrive\");\n\n    exposeTo.leave = leaveEvents.bindEvent;\n    exposeUnbindApi(leaveEvents, exposeTo, \"unbindLeave\");\n  }\n\n  if ($) {\n    exposeApi($.fn);\n  }\n  exposeApi(HTMLElement.prototype);\n  exposeApi(NodeList.prototype);\n  exposeApi(HTMLCollection.prototype);\n  exposeApi(HTMLDocument.prototype);\n  exposeApi(Window.prototype);\n\n  var arrive = {};\n  // expose functions to unbind all arrive/leave events\n  exposeUnbindApi(arriveEvents, arrive, \"unbindAllArrive\");\n  exposeUnbindApi(leaveEvents, arrive, \"unbindAllLeave\");\n\n  return skylark.attach(\"intg.arrive\", arrive);\n\n});\ndefine('skylark-arrive/main',[\r\n\t\"./arrive\"\r\n],function(arrive){\r\n\treturn arrive;\r\n});\ndefine('skylark-arrive', ['skylark-arrive/main'], function (main) { return main; });\n\n"]}