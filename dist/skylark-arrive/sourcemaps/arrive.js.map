{"version":3,"sources":["arrive.js"],"names":["define","skylark","$","window","MutationObserver","HTMLElement","matches","arriveUniqueId","utils","prototype","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","matchesSelector","elem","selector","call","addMethod","object","name","fn","old","length","arguments","apply","this","callCallbacks","callbacksToBeCalled","registrationData","options","onceOnly","firedElems","cb","i","callback","me","unbindEventWithSelectorAndCallback","target","checkChildNodesRecursively","nodes","matchFunc","node","push","childNodes","mergeArrays","firstArr","secondArr","attrName","hasOwnProperty","toElementsArray","elements","EventsBucket","_eventsBucket","_beforeAdding","_beforeRemoving","addEvent","newEvent","removeEvent","compareFunction","registeredEvent","removedEvents","splice","beforeAdding","beforeRemoving","MutationEvents","getObserverConfig","onMutation","eventsBucket","defaultOptions","fireOnAttributesModification","observer","document","getElementsByTagName","e","config","observe","eventData","disconnect","bindEvent","unbindEvent","eventObj","undefined","unbindEventWithSelectorOrCallback","arriveEvents","arriveDefaultOptions","existing","nodeMatchFunc","_id","indexOf","mutationBindEvent","attributes","childList","subtree","mutations","forEach","mutation","newNodes","addedNodes","targetNode","type","querySelectorAll","j","setTimeout","leaveEvents","leaveDefaultOptions","removedNodes","exposeApi","NodeList","HTMLCollection","HTMLDocument","Window","arrive","exposeUnbindApi","attach","exposeTo","funcName","leave"],"mappings":"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","file":"../arrive.js","sourcesContent":["/*globals jQuery,Window,HTMLElement,HTMLDocument,HTMLCollection,NodeList,MutationObserver */\n/*exported Arrive*/\n/*jshint latedef:false */\n\n/*\n * arrive.js\n * v2.4.1\n * https://github.com/uzairfarooq/arrive\n * MIT licensed\n *\n * Copyright (c) 2014-2017 Uzair Farooq\n */\ndefine([\n  \"skylark-langx/skylark\",\n  \"skylark-jquery\"\n],function(skylark,$) {\n\n  \"use strict\";\n\n  if(!window.MutationObserver || typeof HTMLElement === 'undefined'){\n    return; //for unsupported browsers\n  }\n\n  var arriveUniqueId = 0;\n\n  var utils = (function() {\n    var matches = HTMLElement.prototype.matches || HTMLElement.prototype.webkitMatchesSelector || HTMLElement.prototype.mozMatchesSelector\n                  || HTMLElement.prototype.msMatchesSelector;\n\n    return {\n      matchesSelector: function(elem, selector) {\n        return elem instanceof HTMLElement && matches.call(elem, selector);\n      },\n      // to enable function overloading - By John Resig (MIT Licensed)\n      addMethod: function (object, name, fn) {\n        var old = object[ name ];\n        object[ name ] = function(){\n          if ( fn.length == arguments.length ) {\n            return fn.apply( this, arguments );\n          }\n          else if ( typeof old == 'function' ) {\n            return old.apply( this, arguments );\n          }\n        };\n      },\n      callCallbacks: function(callbacksToBeCalled, registrationData) {\n        if (registrationData && registrationData.options.onceOnly && registrationData.firedElems.length == 1) {\n          // as onlyOnce param is true, make sure we fire the event for only one item\n          callbacksToBeCalled = [callbacksToBeCalled[0]];\n        }\n\n        for (var i = 0, cb; (cb = callbacksToBeCalled[i]); i++) {\n          if (cb && cb.callback) {\n            cb.callback.call(cb.elem, cb.elem);\n          }\n        }\n\n        if (registrationData && registrationData.options.onceOnly && registrationData.firedElems.length == 1) {\n          // unbind event after first callback as onceOnly is true.\n          registrationData.me.unbindEventWithSelectorAndCallback.call(\n            registrationData.target, registrationData.selector, registrationData.callback);\n        }\n      },\n      // traverse through all descendants of a node to check if event should be fired for any descendant\n      checkChildNodesRecursively: function(nodes, registrationData, matchFunc, callbacksToBeCalled) {\n        // check each new node if it matches the selector\n        for (var i=0, node; (node = nodes[i]); i++) {\n          if (matchFunc(node, registrationData, callbacksToBeCalled)) {\n            callbacksToBeCalled.push({ callback: registrationData.callback, elem: node });\n          }\n\n          if (node.childNodes.length > 0) {\n            utils.checkChildNodesRecursively(node.childNodes, registrationData, matchFunc, callbacksToBeCalled);\n          }\n        }\n      },\n      mergeArrays: function(firstArr, secondArr){\n        // Overwrites default options with user-defined options.\n        var options = {},\n            attrName;\n        for (attrName in firstArr) {\n          if (firstArr.hasOwnProperty(attrName)) {\n            options[attrName] = firstArr[attrName];\n          }\n        }\n        for (attrName in secondArr) {\n          if (secondArr.hasOwnProperty(attrName)) {\n            options[attrName] = secondArr[attrName];\n          }\n        }\n        return options;\n      },\n      toElementsArray: function (elements) {\n        // check if object is an array (or array like object)\n        // Note: window object has .length property but it's not array of elements so don't consider it an array\n        if (typeof elements !== \"undefined\" && (typeof elements.length !== \"number\" || elements === window)) {\n          elements = [elements];\n        }\n        return elements;\n      }\n    };\n  })();\n\n\n  // Class to maintain state of all registered events of a single type\n  var EventsBucket = (function() {\n    var EventsBucket = function() {\n      // holds all the events\n\n      this._eventsBucket    = [];\n      // function to be called while adding an event, the function should do the event initialization/registration\n      this._beforeAdding    = null;\n      // function to be called while removing an event, the function should do the event destruction\n      this._beforeRemoving  = null;\n    };\n\n    EventsBucket.prototype.addEvent = function(target, selector, options, callback) {\n      var newEvent = {\n        target:             target,\n        selector:           selector,\n        options:            options,\n        callback:           callback,\n        firedElems:         []\n      };\n\n      if (this._beforeAdding) {\n        this._beforeAdding(newEvent);\n      }\n\n      this._eventsBucket.push(newEvent);\n      return newEvent;\n    };\n\n    EventsBucket.prototype.removeEvent = function(compareFunction) {\n      for (var i=this._eventsBucket.length - 1, registeredEvent; (registeredEvent = this._eventsBucket[i]); i--) {\n        if (compareFunction(registeredEvent)) {\n          if (this._beforeRemoving) {\n              this._beforeRemoving(registeredEvent);\n          }\n\n          // mark callback as null so that even if an event mutation was already triggered it does not call callback\n          var removedEvents = this._eventsBucket.splice(i, 1);\n          if (removedEvents && removedEvents.length) {\n            removedEvents[0].callback = null;\n          }\n        }\n      }\n    };\n\n    EventsBucket.prototype.beforeAdding = function(beforeAdding) {\n      this._beforeAdding = beforeAdding;\n    };\n\n    EventsBucket.prototype.beforeRemoving = function(beforeRemoving) {\n      this._beforeRemoving = beforeRemoving;\n    };\n\n    return EventsBucket;\n  })();\n\n\n  /**\n   * @constructor\n   * General class for binding/unbinding arrive and leave events\n   */\n  var MutationEvents = function(getObserverConfig, onMutation) {\n    var eventsBucket    = new EventsBucket(),\n        me              = this;\n\n    var defaultOptions = {\n      fireOnAttributesModification: false\n    };\n\n    // actual event registration before adding it to bucket\n    eventsBucket.beforeAdding(function(registrationData) {\n      var\n        target    = registrationData.target,\n        observer;\n\n      // mutation observer does not work on window or document\n      if (target === window.document || target === window) {\n        target = document.getElementsByTagName(\"html\")[0];\n      }\n\n      // Create an observer instance\n      observer = new MutationObserver(function(e) {\n        onMutation.call(this, e, registrationData);\n      });\n\n      var config = getObserverConfig(registrationData.options);\n\n      observer.observe(target, config);\n\n      registrationData.observer = observer;\n      registrationData.me = me;\n    });\n\n    // cleanup/unregister before removing an event\n    eventsBucket.beforeRemoving(function (eventData) {\n      eventData.observer.disconnect();\n    });\n\n    this.bindEvent = function(selector, options, callback) {\n      options = utils.mergeArrays(defaultOptions, options);\n\n      var elements = utils.toElementsArray(this);\n\n      for (var i = 0; i < elements.length; i++) {\n        eventsBucket.addEvent(elements[i], selector, options, callback);\n      }\n    };\n\n    this.unbindEvent = function() {\n      var elements = utils.toElementsArray(this);\n      eventsBucket.removeEvent(function(eventObj) {\n        for (var i = 0; i < elements.length; i++) {\n          if (this === undefined || eventObj.target === elements[i]) {\n            return true;\n          }\n        }\n        return false;\n      });\n    };\n\n    this.unbindEventWithSelectorOrCallback = function(selector) {\n      var elements = utils.toElementsArray(this),\n          callback = selector,\n          compareFunction;\n\n      if (typeof selector === \"function\") {\n        compareFunction = function(eventObj) {\n          for (var i = 0; i < elements.length; i++) {\n            if ((this === undefined || eventObj.target === elements[i]) && eventObj.callback === callback) {\n              return true;\n            }\n          }\n          return false;\n        };\n      }\n      else {\n        compareFunction = function(eventObj) {\n          for (var i = 0; i < elements.length; i++) {\n            if ((this === undefined || eventObj.target === elements[i]) && eventObj.selector === selector) {\n              return true;\n            }\n          }\n          return false;\n        };\n      }\n      eventsBucket.removeEvent(compareFunction);\n    };\n\n    this.unbindEventWithSelectorAndCallback = function(selector, callback) {\n      var elements = utils.toElementsArray(this);\n      eventsBucket.removeEvent(function(eventObj) {\n          for (var i = 0; i < elements.length; i++) {\n            if ((this === undefined || eventObj.target === elements[i]) && eventObj.selector === selector && eventObj.callback === callback) {\n              return true;\n            }\n          }\n          return false;\n      });\n    };\n\n    return this;\n  };\n\n\n  /**\n   * @constructor\n   * Processes 'arrive' events\n   */\n  var ArriveEvents = function() {\n    // Default options for 'arrive' event\n    var arriveDefaultOptions = {\n      fireOnAttributesModification: false,\n      onceOnly: false,\n      existing: false\n    };\n\n    function getArriveObserverConfig(options) {\n      var config = {\n        attributes: false,\n        childList: true,\n        subtree: true\n      };\n\n      if (options.fireOnAttributesModification) {\n        config.attributes = true;\n      }\n\n      return config;\n    }\n\n    function onArriveMutation(mutations, registrationData) {\n      mutations.forEach(function( mutation ) {\n        var newNodes    = mutation.addedNodes,\n            targetNode = mutation.target,\n            callbacksToBeCalled = [],\n            node;\n\n        // If new nodes are added\n        if( newNodes !== null && newNodes.length > 0 ) {\n          utils.checkChildNodesRecursively(newNodes, registrationData, nodeMatchFunc, callbacksToBeCalled);\n        }\n        else if (mutation.type === \"attributes\") {\n          if (nodeMatchFunc(targetNode, registrationData, callbacksToBeCalled)) {\n            callbacksToBeCalled.push({ callback: registrationData.callback, elem: targetNode });\n          }\n        }\n\n        utils.callCallbacks(callbacksToBeCalled, registrationData);\n      });\n    }\n\n    function nodeMatchFunc(node, registrationData, callbacksToBeCalled) {\n      // check a single node to see if it matches the selector\n      if (utils.matchesSelector(node, registrationData.selector)) {\n        if(node._id === undefined) {\n          node._id = arriveUniqueId++;\n        }\n        // make sure the arrive event is not already fired for the element\n        if (registrationData.firedElems.indexOf(node._id) == -1) {\n          registrationData.firedElems.push(node._id);\n\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    arriveEvents = new MutationEvents(getArriveObserverConfig, onArriveMutation);\n\n    var mutationBindEvent = arriveEvents.bindEvent;\n\n    // override bindEvent function\n    arriveEvents.bindEvent = function(selector, options, callback) {\n\n      if (typeof callback === \"undefined\") {\n        callback = options;\n        options = arriveDefaultOptions;\n      } else {\n        options = utils.mergeArrays(arriveDefaultOptions, options);\n      }\n\n      var elements = utils.toElementsArray(this);\n\n      if (options.existing) {\n        var existing = [];\n\n        for (var i = 0; i < elements.length; i++) {\n          var nodes = elements[i].querySelectorAll(selector);\n          for (var j = 0; j < nodes.length; j++) {\n            existing.push({ callback: callback, elem: nodes[j] });\n          }\n        }\n\n        // no need to bind event if the callback has to be fired only once and we have already found the element\n        if (options.onceOnly && existing.length) {\n          return callback.call(existing[0].elem, existing[0].elem);\n        }\n\n        setTimeout(utils.callCallbacks, 1, existing);\n      }\n\n      mutationBindEvent.call(this, selector, options, callback);\n    };\n\n    return arriveEvents;\n  };\n\n\n  /**\n   * @constructor\n   * Processes 'leave' events\n   */\n  var LeaveEvents = function() {\n    // Default options for 'leave' event\n    var leaveDefaultOptions = {};\n\n    function getLeaveObserverConfig() {\n      var config = {\n        childList: true,\n        subtree: true\n      };\n\n      return config;\n    }\n\n    function onLeaveMutation(mutations, registrationData) {\n      mutations.forEach(function( mutation ) {\n        var removedNodes  = mutation.removedNodes,\n            callbacksToBeCalled = [];\n\n        if( removedNodes !== null && removedNodes.length > 0 ) {\n          utils.checkChildNodesRecursively(removedNodes, registrationData, nodeMatchFunc, callbacksToBeCalled);\n        }\n\n        utils.callCallbacks(callbacksToBeCalled, registrationData);\n      });\n    }\n\n    function nodeMatchFunc(node, registrationData) {\n      return utils.matchesSelector(node, registrationData.selector);\n    }\n\n    leaveEvents = new MutationEvents(getLeaveObserverConfig, onLeaveMutation);\n\n    var mutationBindEvent = leaveEvents.bindEvent;\n\n    // override bindEvent function\n    leaveEvents.bindEvent = function(selector, options, callback) {\n\n      if (typeof callback === \"undefined\") {\n        callback = options;\n        options = leaveDefaultOptions;\n      } else {\n        options = utils.mergeArrays(leaveDefaultOptions, options);\n      }\n\n      mutationBindEvent.call(this, selector, options, callback);\n    };\n\n    return leaveEvents;\n  };\n\n\n  var arriveEvents = new ArriveEvents(),\n      leaveEvents  = new LeaveEvents();\n\n  function exposeUnbindApi(eventObj, exposeTo, funcName) {\n    // expose unbind function with function overriding\n    utils.addMethod(exposeTo, funcName, eventObj.unbindEvent);\n    utils.addMethod(exposeTo, funcName, eventObj.unbindEventWithSelectorOrCallback);\n    utils.addMethod(exposeTo, funcName, eventObj.unbindEventWithSelectorAndCallback);\n  }\n\n  /*** expose APIs ***/\n  function exposeApi(exposeTo) {\n    exposeTo.arrive = arriveEvents.bindEvent;\n    exposeUnbindApi(arriveEvents, exposeTo, \"unbindArrive\");\n\n    exposeTo.leave = leaveEvents.bindEvent;\n    exposeUnbindApi(leaveEvents, exposeTo, \"unbindLeave\");\n  }\n\n  if ($) {\n    exposeApi($.fn);\n  }\n  exposeApi(HTMLElement.prototype);\n  exposeApi(NodeList.prototype);\n  exposeApi(HTMLCollection.prototype);\n  exposeApi(HTMLDocument.prototype);\n  exposeApi(Window.prototype);\n\n  var arrive = {};\n  // expose functions to unbind all arrive/leave events\n  exposeUnbindApi(arriveEvents, arrive, \"unbindAllArrive\");\n  exposeUnbindApi(leaveEvents, arrive, \"unbindAllLeave\");\n\n  return skylark.attach(\"intg.arrive\", arrive);\n\n});"]}